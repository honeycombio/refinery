package main

import (
	"context"
	"fmt"
	"math/rand"
	"time"

	"github.com/dgryski/go-wyhash"
	"github.com/honeycombio/refinery/centralstore"
	"github.com/honeycombio/refinery/internal/otelutil"
	"github.com/honeycombio/refinery/refinerytrace"
)

type traceGenerator struct {
	Granularity      Duration
	MinTraceLength   int
	MaxTraceLength   int
	MaxTraceDuration Duration
	TotalNodeCount   int
	NodeIndex        int
	hashseed         uint64
	tracer           refinerytrace.Tracer
}

func NewTraceGenerator(opts CmdLineOptions, index int, tracer refinerytrace.Tracer) *traceGenerator {
	return &traceGenerator{
		Granularity:      opts.TraceIDGranularity,
		MinTraceLength:   opts.MinTraceLength,
		MaxTraceLength:   opts.MaxTraceLength,
		MaxTraceDuration: opts.MaxTraceDuration,
		TotalNodeCount:   opts.TotalNodeCount,
		NodeIndex:        index,
		tracer:           tracer,
	}
}

// TraceID is generated deterministically from the current time to the nearest granularity; this
// means that the same traceIDs will be generated if the program is run at the same time on different
// machines. Creating a new traceID sets the hashseed to a value based on the traceID, which gives us
// a deterministic way to generate random numbers for the trace.
func (t *traceGenerator) getTraceID() string {
	ts := time.Now().Truncate(time.Duration(t.Granularity)).UnixMilli()
	h1 := wyhash.Hash([]byte("traceid1"), uint64(ts))
	h2 := wyhash.Hash([]byte("traceid2"), h1)
	t.hashseed = wyhash.Hash([]byte("hashseed"), h2)
	return fmt.Sprintf("%016x%016x", h1, h2)
}

// SpanID is also deterministic.
func (t *traceGenerator) getSpanID(tid string) string {
	ts := t.Uint64()
	h := wyhash.Hash([]byte(tid), uint64(ts))
	return fmt.Sprintf("%016x", h)
}

func (t *traceGenerator) getKeyFields() map[string]interface{} {
	ops := []string{"GET", "PUT", "POST", "DELETE", "HEAD"}
	paths := []string{"/path1", "/path2", "/path3", "/path4", "/path5"}
	statuses := []int{200, 201, 202, 203, 204, 400, 401, 402, 403, 404, 500}
	return map[string]interface{}{
		"operation": ops[rand.Intn(len(ops))],
		"path":      paths[rand.Intn(len(paths))],
		"status":    statuses[rand.Intn(len(statuses))],
	}
}

// mySpan returns true if the span with the given traceID and spanID should be generated by this node.
// If TotalNodeCount is 1, then we always generate the span.
func (t *traceGenerator) mySpan(traceID string, spanID string) bool {
	if t.TotalNodeCount == 1 {
		return true
	}
	h := wyhash.Hash([]byte(traceID), 4523987354)
	h = wyhash.Hash([]byte(spanID), h)
	return (h % uint64(t.TotalNodeCount)) == uint64(t.NodeIndex)
}

// Intn returns a random number between 0 and n-1, given a traceID. This
// function provides a deterministic means to let all the nodes generate
// the same values for the same generated traceID.
func (t *traceGenerator) Intn(n int) int {
	return int(t.Uint64() % uint64(n))
}

func (t *traceGenerator) Uint64() uint64 {
	t.hashseed = wyhash.Hash([]byte("next"), t.hashseed)
	return t.hashseed
}

// generateTrace generates a trace with the specified traceID, a given number of
// spans spread out for the given duration. It puts the spans into a channel and
// expects to be run as a goroutine; it terminates when it sends the root span.
// MinDuration of the trace is always the granularity.
func (t *traceGenerator) generateTrace(ctx context.Context, out chan *centralstore.CentralSpan, stop <-chan struct{}, traceIDchan chan string) {
	_, root := t.tracer.Start(ctx, "generate_trace")
	defer root.End()

	// create a new traceID which also seeds the random number generator
	traceid := t.getTraceID()
	traceIDchan <- traceid

	spanCount := t.Intn(t.MaxTraceLength-t.MinTraceLength) + t.MinTraceLength

	// decide how many special spans to include
	spanEventCount := 0
	spanLinkCount := 0
	if spanCount > 4 {
		nspecials := t.Intn(spanCount - 4)
		switch nspecials {
		case 0:
			// no special spans
		case 1:
			spanEventCount = 1
		case 2:
			spanEventCount = 1
			spanLinkCount = 1
		default:
			spanEventCount = t.Intn(nspecials)
			spanLinkCount = nspecials - spanEventCount
		}
	}

	// decide how long the trace should last
	dur := time.Duration(t.Intn(int(t.MaxTraceDuration-t.Granularity)) + int(t.Granularity))
	trace := &centralstore.CentralTrace{
		TraceID: traceid,
		Spans:   make([]*centralstore.CentralSpan, 0, spanCount),
	}

	otelutil.AddSpanFields(root, map[string]interface{}{
		"trace_id":         traceid,
		"span_count":       spanCount,
		"node_index":       t.NodeIndex,
		"span_event_count": spanEventCount,
		"span_link_count":  spanLinkCount,
		"duration_ms":      dur / time.Millisecond,
	})

	// generate the root span
	rootFields := t.getKeyFields()
	rootFields["spanCount"] = spanCount
	rootFields["spanEventCount"] = spanEventCount
	rootFields["spanLinkCount"] = spanLinkCount
	rootSpan := &centralstore.CentralSpan{
		TraceID:   trace.TraceID,
		SpanID:    t.getSpanID(trace.TraceID),
		Type:      centralstore.SpanTypeNormal,
		KeyFields: rootFields,
		IsRoot:    true,
	}
	trace.Spans = append(trace.Spans, rootSpan)

	// generate the children
	for i := 1; i < spanCount; i++ {
		span := &centralstore.CentralSpan{
			TraceID:   trace.TraceID,
			SpanID:    t.getSpanID(trace.TraceID),
			ParentID:  trace.Spans[i-1].SpanID,
			Type:      centralstore.SpanTypeNormal,
			KeyFields: t.getKeyFields(),
		}
		trace.Spans = append(trace.Spans, span)
	}
	// the first spans after the root span are the span events
	for i := 0; i < spanEventCount; i++ {
		trace.Spans[i+1].Type = centralstore.SpanTypeEvent
	}
	// the next spans are the span links
	for i := spanEventCount; i < spanEventCount+spanLinkCount; i++ {
		trace.Spans[i+1].Type = centralstore.SpanTypeLink
	}

	// Now we have a trace, set up a timer to send all the spans in reverse
	// order spread out over the duration so the root span is last. If we see
	// the stop signal, we stop immediately and won't send any more traces (or
	// the root span).
	ticker := time.NewTicker(dur / time.Duration(spanCount))
	defer ticker.Stop()
	for counter := spanCount; counter > 0; counter-- {
		select {
		case <-stop:
			return
		case <-ticker.C:
			_, span := t.tracer.Start(ctx, "send_span")
			otelutil.AddSpanFields(span, map[string]interface{}{
				"trace_id": traceid,
				"span_id":  trace.Spans[counter-1].SpanID,
				"index":    counter - 1,
			})
			// only send the span if it's ours
			if t.mySpan(traceid, trace.Spans[counter-1].SpanID) {
				otelutil.AddSpanField(span, "sent", true)
				out <- trace.Spans[counter-1]
			} else {
				otelutil.AddSpanField(span, "sent", false)
			}
			span.End()
		}
	}
}
